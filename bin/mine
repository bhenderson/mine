#!/bin/bash

export mine_path="$( cd $(dirname "$BASH_SOURCE")/..; pwd )"
# being sourced?
[[ "$BASH_SOURCE" != "$0" ]] && {
  export PATH="$mine_path/bin:$PATH"

  # setup top level function
  # eval anything that comes out on FD3, but still print FD1 to stdout
  mine() {
    # open
    exec 3>&1 4>&1

    eval "`command mine "$@" 3>&1 >&4`"

    # close
    exec 3>&- 4>&-
  }
  export -f mine

  [[ "$1" == 'setup' ]] && mine setup

  mine use default --quiet
  return
}

# the rest of this script gets run as a command

# is there a better way to test FD 3?
[[ -a "/dev/fd/3" ]] || exec 3>&1

# add libs
export PATH="$mine_path/lib:$PATH"
source 'common.sh'
export command_name=mine

usage() {
  [[ "$@" ]] && echo "$@"
cat <<-EOS
Usage: $command_name [command] [options]

  Commands:
    alias
    copy
    help
    install
    list
    remove
    setup
    use

EOS
  exit 1
}

# TODO `use' should be default. ie. mine 192
parse_opts() {
  case "$1" in
    help)
      [[ "$2" ]] && parse_opts "$2" "--help"
      usage
    ;;
    alias|copy|install|list|remove|setup|use)
      cmd=$1; shift
      source "$cmd.sh" "$@"
    ;;
    # shortcuts
    ls)
      shift
      source "list.sh" "$@"
    ;;
    --reset-system)
      reset_system
      shift
    ;;
    *)
      usage "unknown option '$1'"
    ;;
  esac
}

parse_opts "$@"

update_ruby

# vim: ft=sh :
